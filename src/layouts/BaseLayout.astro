---
import SEOHead from '../components/SEOHead.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import '../styles/global.css';

interface Props {
  title: string;
  description: string;
  canonical?: string;
  ogImage?: string;
  type?: 'website' | 'article';
  publishDate?: string;
  modifiedDate?: string;
  schema?: Record<string, any>;
  noHeader?: boolean;
}
const props = Astro.props;
---
<!DOCTYPE html>
<html lang="en">
<head>
  <SEOHead {...props} />
</head>
<body class="min-h-screen">
  <!-- Particle Canvas Background -->
  <canvas id="bg-canvas"></canvas>

  <!-- Ambient Glow Orbs -->
  <div class="glow-orb glow-orb-1"></div>
  <div class="glow-orb glow-orb-2"></div>
  <div class="glow-orb glow-orb-3"></div>

  {!props.noHeader && <Header />}

  <main class={`relative z-10 ${props.noHeader ? '' : 'pt-16'}`}>
    <slot />
  </main>

  <div class="relative z-10">
    <Footer />
  </div>

  <!-- Global JS: Particles + Scroll Reveal -->
  <script>
    // ═══ PARTICLE CANVAS ═══
    (function() {
      const canvas = document.getElementById('bg-canvas') as HTMLCanvasElement;
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      if (!ctx) return;

      let particles: { x: number; y: number; size: number; speedX: number; speedY: number; opacity: number; hue: number }[] = [];

      function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        initParticles();
      }

      function initParticles() {
        const count = Math.min(Math.floor((canvas.width * canvas.height) / 15000), 120);
        particles = [];
        for (let i = 0; i < count; i++) {
          particles.push({
            x: Math.random() * canvas.width,
            y: Math.random() * canvas.height,
            size: Math.random() * 1.5 + 0.5,
            speedX: (Math.random() - 0.5) * 0.3,
            speedY: (Math.random() - 0.5) * 0.3,
            opacity: Math.random() * 0.4 + 0.1,
            hue: Math.random() > 0.5 ? 240 : 190,
          });
        }
      }

      function animate() {
        ctx!.clearRect(0, 0, canvas.width, canvas.height);
        for (const p of particles) {
          p.x += p.speedX;
          p.y += p.speedY;
          if (p.x < 0 || p.x > canvas.width) p.speedX *= -1;
          if (p.y < 0 || p.y > canvas.height) p.speedY *= -1;
          ctx!.beginPath();
          ctx!.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          ctx!.fillStyle = `hsla(${p.hue}, 80%, 70%, ${p.opacity})`;
          ctx!.fill();
        }
        // Draw connections
        for (let i = 0; i < particles.length; i++) {
          for (let j = i + 1; j < particles.length; j++) {
            const dx = particles[i].x - particles[j].x;
            const dy = particles[i].y - particles[j].y;
            const dist = Math.sqrt(dx * dx + dy * dy);
            if (dist < 120) {
              ctx!.beginPath();
              ctx!.moveTo(particles[i].x, particles[i].y);
              ctx!.lineTo(particles[j].x, particles[j].y);
              ctx!.strokeStyle = `rgba(99, 102, 241, ${0.06 * (1 - dist / 120)})`;
              ctx!.lineWidth = 0.5;
              ctx!.stroke();
            }
          }
        }
        requestAnimationFrame(animate);
      }

      resize();
      window.addEventListener('resize', resize);
      animate();
    })();

    // ═══ SCROLL REVEAL ═══
    (function() {
      const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            entry.target.classList.add('visible');
          }
        });
      }, { threshold: 0.1, rootMargin: '0px 0px -40px 0px' });

      document.querySelectorAll('.reveal, .reveal-stagger').forEach(el => observer.observe(el));
    })();
  </script>
</body>
</html>
